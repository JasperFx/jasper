<!--title:Jasper as a Mediator-->

::: tip warning
All of the code on this page is from [the InMemoryMediator sample project](https://github.com/JasperFx/JasperSamples/tree/master/InMemoryMediator).
:::

Recently there's been some renewed interest in the old [Gof Mediator pattern](https://en.wikipedia.org/wiki/Mediator_pattern) as a way to isolate
the actual functionality of web services and applications from the mechanics of HTTP request handling. In more concrete terms for .NET developers,
a mediator tool allows you to keep MVC Core code ceremony out of your application business logic and service layer. It wasn't the original motivation of the project,
but Jasper can be used as a full-featured mediator.


Let's jump into a sample project. Let's say that your system creates and tracks *Items* of some sort. One of the API requirements is to expose an HTTP
endpoint that can accept an input that will create and persist a new `Item`, while also publishing an `ItemCreated` event message to any other system
(or internal listener within the same system). For the technology stack, let's use:

* [MVC Core](https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-3.1) as the Web API framework
* Jasper as our mediator of course!
* Sql Server as the backing database store, using <[linkto:documentation/durability/sqlserver;title=Jasper's Sql Server message persistence]>
* [EF Core](https://docs.microsoft.com/en-us/ef/core/) as the persistence mechanism

First off, let's start a new project with the `dotnet new webapi` template. Next, let's put all the Jasper configuration into a
custom <[linkto:documentation/bootstrapping;title=JasperOptions]> class like this:

snippet: sample_InMemoryMediator_JasperConfig

From there, we'll slightly modify the `Program` file generated by the `webapi` template to add Jasper and opt
into Jasper's <[linkto:documentation/console;title=extended command line support]>:

snippet: sample_InMemoryMediatorProgram

Now, let's add a Jasper message handler that will:

1. Handle a new `CreateItemCommand` message
1. Create a new `Item` entity and persist that with a new `ItemsDbContext` custom EF Core `DbContext`
1. Create and publish a new `ItemCreated` event message reflecting the new `Item`

Using idiomatic Jasper, that handler looks like this:

snippet: sample_InMemoryMediator_Items

**Note**, as long as this handler class is public and in the main application assembly, Jasper is going
to find it and wire it up inside its execution pipeline. There's no explicit code or funky IoC registration necessary.


Now, moving up to the controller layer, we can add a controller like this:

snippet: sample_InMemoryMediator_UseJasperAsMediatorController

There isn't much to this code -- and that's the entire point! When Jasper registers itself into
a .NET Core application, it adds the `ICommandBus` service to the underlying system IoC container
so it can be injected into controller classes as a constructor argument or as a method argument
if you prefer to use the `[FromServices]` attribute and method injection. The `ICommandBus.Invoke(message)`
method takes the message passed in, finds the correct execution path for the message type, and
executes the correct Jasper handler(s) as well as any of the registered <[linkto:documentation/execution/middleware_and_codegen]>.

::: tip warning
This execution happens inline, and does not involve any of Jasper's <[linkto:documentation/execution/errorhandling]>
functionality that would apply to enqueued messages.
:::

See also:

 * <[linkto:documentation/execution/cascading]> for a better explanation of how the `ItemCreated`
event message is automatically published if the handler success.
* <[linkto:documentation/execution]> for the details of how to write Jasper message handlers and how they
are discovered

As a contrast, here's what the same functionality looks like if you write all the functionality out
explicitly in a controller action:

snippet: sample_InMemoryMediator_DoItAllMyselfItemController

So one, there's just more going on in the `Create()` method above because you're needing to do a little bit of
additional work that Jasper can do for you inside of its execution pipeline (the outbox mechanics, the cascading message getting published, transaction management).
Also though, you're now mixing up MVC controller stuff like the `[HttpPost]` attribute to control the
Url for the endpoint and the service application code that exercises the data and domain model layers.


## Getting a Response

The controller methods above would both return an empty response body and the default `200 OK` status code.
But what if you want to return some kind of response body that gave the client of the web service some
kind of contextual information about the newly created `Item`.

To that end, let's write a different controller action that will relay the body of the `ItemCreated`
output of the message handler to the HTTP response body (and assume we'll use JSON because that makes the
example code simpler):

snippet: sample_InMemoryMediator_WithResponseController

Using the `ICommandBus.Invoke<T>(message)` overload, the returned `ItemCreated` response
of the message handler is returned from the `Invoke()` message. To be perfectly clear, this only
works if the message handler method returns a cascading message of the exact same type of the
designated `T` parameter.
